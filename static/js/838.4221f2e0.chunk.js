"use strict";(self.webpackChunkfrontend_concepts=self.webpackChunkfrontend_concepts||[]).push([[838,921],{6921:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});n(5043);var a=n(2347),s=n(579);const i=e=>{let{contentList:t}=e;return(0,s.jsx)(s.Fragment,{children:null===t||void 0===t?void 0:t.map(((e,t)=>{var n;return(0,s.jsxs)(a.A,{sx:{pl:e.padLeft?4:0},children:[(0,s.jsx)("h2",{children:e.contentName}),e.contentList&&(0,s.jsx)("ul",{className:"list_style_content",children:null===(n=e.contentList)||void 0===n?void 0:n.map(((t,n)=>(0,s.jsx)("li",{dangerouslySetInnerHTML:{__html:t}},`${e.contentName}_${n}`)))}),e.constentTable&&(0,s.jsx)(a.A,{className:"scrollbar_auto_styles",children:(0,s.jsxs)("table",{children:[(0,s.jsx)("thead",{children:(0,s.jsx)("tr",{children:e.constentTable.headers.map(((t,n)=>(0,s.jsx)("th",{children:t},`${e.contentName}_${n}`)))})}),(0,s.jsx)("tbody",{children:e.constentTable.rows.map(((t,n)=>(0,s.jsx)("tr",{children:t.map(((t,a)=>(0,s.jsx)("td",{children:t},`${e.contentName}_${n}_${a}`)))},`${e.contentName}_${n}`)))})]})}),e.contentCodeBlock&&(0,s.jsx)("pre",{children:(0,s.jsx)("code",{children:e.contentCodeBlock})})]},t)}))})}},6838:(e,t,n)=>{n.r(t),n.d(t,{default:()=>o});n(5043);var a=n(6921),s=n(579);const i=[{contentName:"1. React",contentList:["It is a JavaScript library for building fast, interactive, and scalable user interfaces (UI), primarily for web applications.","It is declarative, efficient, and flexible.","It is component-based, meaning the UI is split into independent, reusable pieces."]},{contentName:"a. Advantages",contentList:['<span class="semibold_italic">Component-Based Architecture \u2192</span> Reusable components make development faster and code more maintainable.','<span class="semibold_italic">Fast Rendering with Virtual DOM \u2192</span> React updates only the necessary parts of the UI, improving performance.','<span class="semibold_italic">Unidirectional Data Flow \u2192</span> Ensures predictable state management, reducing bugs and making debugging easier.','<span class="semibold_italic">Rich Ecosystem & Community Support \u2192</span> Huge open-source support with libraries like Redux, React Query, and Material UI.','<span class="semibold_italic">Easy to Learn & Use \u2192</span> JSX simplifies UI development, making React beginner-friendly.','<span class="semibold_italic">Cross-Platform Development \u2192</span> React Native allows code reuse for mobile apps (iOS & Android).'],padLeft:!0},{contentName:"b. Limitations",contentList:['<span class="semibold_italic">Not a Full Framework:</span> Only handles UI, needs React Router for navigation, Redux/Context API for state, API handling etc.','<span class="semibold_italic">SEO Issues:</span> React uses client-side rendering, which can hurt SEO. Solution: Use Next.js for SSR.','<span class="semibold_italic">Frequent Updates:</span> React evolves quickly (e.g., Class Components \u2192 Hooks), requiring constant learning.','<span class="semibold_italic">Prop Drilling & Complex State:</span> Passing data deep in components is painful; needs Context API, Redux, or Zustand.','<span class="semibold_italic">Not Ideal for Small/Static Apps:</span> Lightweight alternatives like Svelte, Vue, or Astro are better in some cases.'],padLeft:!0},{contentName:"2. JSX (JavaScript XML)",contentList:["It is a syntax extension for JavaScript, similar to XML/HTML, used with React to describe UI components.","It allows writing HTML in React and JavaScript code in the same file.","It is not a necessity but a convention for writing React components."]},{contentName:"a. Advantages",contentList:['<span class="semibold_italic">Easy to Write & Read:</span> Combines HTML & JS, making code more readable and maintainable.','<span class="semibold_italic">Prevents Injection Attacks:</span> Automatically escapes user inputs, preventing XSS attacks.','<span class="semibold_italic">Faster Development:</span> Reduces context switching between HTML and JS, improving productivity.'],padLeft:!0},{contentName:"b. How JSX works?",contentList:["JSX is transpiled to JavaScript using Babel, converting HTML-like syntax to React.createElement() calls.","React.createElement() creates a virtual DOM object (React Element) for each JSX tag.","React then updates the actual DOM based on the virtual DOM changes."],padLeft:!0},{contentName:"3. Virtual DOM",contentList:["It is a lightweight copy of the actual DOM, used by React to improve performance.","React compares the virtual DOM with the actual DOM and updates only the changed parts.","It reduces the number of DOM manipulations, improving rendering speed."]},{contentName:"4. Reconciliation Process",contentList:["It is is the process React uses to update the Real DOM efficiently when the state or props of a component change. Instead of re-rendering the entire UI, React compares the new Virtual DOM with the previous one and updates only the changed parts in the actual DOM."]},{contentName:"a. How Virtual DOM Updates work? (Reconciliation Process)",contentList:['<span class="semibold_italic">Render Phase:</span> When the UI changes, React creates a new virtual DOM tree.','<span class="semibold_italic">Diffing Phase:</span> React compares the new virtual DOM with the previous one using the diffing algorithm to find the changes.','<span class="semibold_italic">Reconciliation Phase:</span> Instead of updating the actual DOM directly, React updates only the changed parts, improving performance.'],contentCodeBlock:'function TextUpdater() {\n  const [text, setText] = useState("Hello, world!");\n\n  const updateText = () => {\n    setText("Hello, React!");\n  };\n\n  return (\n    <div>\n      <p>{text}</p>\n      <button onClick={updateText}>Change Text</button>\n    </div>\n  );\n}\n\n/*\n  How This Works (Step-by-Step)\n\n  1. Initial Render:\n     - React creates a Virtual DOM for the component with <p>Hello, world!</p>.\n\n  2. State Update (onClick Event):\n     - The button is clicked, updating the state to "Hello, React!".\n     - A new Virtual DOM tree is created with <p>Hello, React!</p>.\n\n  3. Diffing (Comparing Old vs. New Virtual DOM):\n     - React detects that only the text inside <p> has changed.\n\n  4. Reconciliation (Efficient Update to Real DOM):\n     - Instead of re-rendering the entire <p> element, React updates only the text node inside.\n*/',padLeft:!0},{contentName:"5. Difference with Real DOM & Shadow DOM",constentTable:{headers:["Features","Virtual DOM","Real DOM","Shadow DOM"],rows:[["Definition","A lightweight copy of the Real DOM used by React to track the changes efficiently before updating the Real DOM.","The actual browser-rendered HTML structure that users interact with. ","A separate, encapsulated DOM inside an element (mostly used in Web Components) to prevent style and script conflicts."],["Performance","Faster updates due to minimal DOM manipulations.","Slower updates as it directly interacts with the browser and whole repaints happen.","Improves performance by keeping styles and elements scoped to a single component."],["Rendering","Creates a virtual tree of React elements that mirrors the actual DOM.","Directly renders the HTML structure on the browser.","Renders the DOM inside a shadow root, isolated from the main document."],["Manipulation","React compares old and new VDOM, updating only the necessary parts in the Real DOM.","Any change directly affects the page, causing a reflow and repaint.","Elements inside a Shadow DOM are independent of the main DOM."],["Use Case","React uses VDOM to improve performance and reduce re-renders.","Traditional websites and applications that don\u2019t use a framework.","Web Components that need encapsulation and reusability."]]}}],o=()=>(0,s.jsx)(s.Fragment,{children:(0,s.jsx)(a.default,{contentList:i})})}}]);
//# sourceMappingURL=838.4221f2e0.chunk.js.map