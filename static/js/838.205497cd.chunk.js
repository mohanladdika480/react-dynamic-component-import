"use strict";(self.webpackChunkfrontend_concepts=self.webpackChunkfrontend_concepts||[]).push([[127,446,678,838],{6446:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});t(5043);var o=t(1187),a=t(579);const i=e=>{const{handleClick:n,styles:t,children:i,disabled:s}=e;return(0,a.jsx)(o.A,{sx:{background:"transparent",border:"1px solid #880E4F",color:"#880E4F",textTransform:"none",fontWeight:"600",...t,"&:disabled":{opacity:.4,border:"1px solid grey",color:"grey"}},onClick:n,disabled:s,children:i})}},7678:(e,n,t)=>{t.r(n),t.d(n,{default:()=>d});var o=t(5043),a=t(2347),i=t(9662),s=t(579);const r=(0,i.A)((0,s.jsx)("path",{d:"M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20z"}),"ArrowBack");var c=t(6446);const d=e=>{let{conceptData:n}=e;const{topic:t,subTopics:i}=n,[d,l]=(0,o.useState)(null),p=()=>{l(null)},h=()=>{window.scrollTo(0,0,"smooth"),l(d+1)},m=()=>{window.scrollTo(0,0,"smooth"),l(d-1)};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("h1",{children:t}),d?(()=>{const{topicName:e,detailedList:n}=null===i||void 0===i?void 0:i[d-1];return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(a.A,{sx:{display:"flex",alignItems:"center"},children:[(0,s.jsx)(r,{onClick:p,sx:{mr:"10px",cursor:"pointer"}}),(0,s.jsx)("h2",{className:"text_color_1 no_margin",children:e})]}),null===n||void 0===n?void 0:n.map(((e,n)=>{var t,o,i;return(0,s.jsxs)(a.A,{sx:{pl:e.padLeft?4:0},children:[(0,s.jsx)("h2",{children:e.contentName}),(null===e||void 0===e?void 0:e.contentList)&&(0,s.jsx)("ul",{className:"list_style_content",children:null===e||void 0===e||null===(t=e.contentList)||void 0===t?void 0:t.map(((n,t)=>(0,s.jsx)("li",{dangerouslySetInnerHTML:{__html:n}},`${e.contentName}_${t}`)))}),(null===e||void 0===e?void 0:e.contentTable)&&(0,s.jsx)(a.A,{className:"scrollbar_auto_styles",children:(0,s.jsxs)("table",{children:[(0,s.jsx)("thead",{children:(0,s.jsx)("tr",{children:null===e||void 0===e||null===(o=e.contentTable)||void 0===o?void 0:o.headers.map(((n,t)=>(0,s.jsx)("th",{children:n},`${e.contentName}_${t}`)))})}),(0,s.jsx)("tbody",{children:null===e||void 0===e||null===(i=e.contentTable)||void 0===i?void 0:i.rows.map(((n,t)=>(0,s.jsx)("tr",{children:n.map(((n,o)=>(0,s.jsx)("td",{children:n},`${e.contentName}_${t}_${o}`)))},`${e.contentName}_${t}`)))})]})}),e.contentCodeBlock&&(0,s.jsx)("pre",{children:(0,s.jsx)("code",{children:e.contentCodeBlock})})]},n)})),(0,s.jsxs)(a.A,{sx:{mt:"20px",display:"flex",justifyContent:"flex-end",gap:"10px"},children:[(0,s.jsx)(c.default,{handleClick:m,disabled:1===d,children:"\u2bc7 Previous"}),(0,s.jsx)(c.default,{handleClick:h,disabled:d===(null===i||void 0===i?void 0:i.length),children:"Next \u2bc8"})]})]})})():(0,s.jsx)("ol",{className:"list_heading",children:null===n||void 0===n?void 0:n.subTopics.map(((e,n)=>(0,s.jsx)("li",{onClick:()=>(e=>{l(e+1)})(n),children:null===e||void 0===e?void 0:e.topicName},n)))})]})}},6838:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});t(5043);var o=t(7678),a=t(7127),i=t(579);const s={topic:"Core React",subTopics:[{topicName:"React, JSX, Virtual DOM vs Real DOM, Reconciliation",detailedList:a.reactConcepts},{topicName:"Components in React, Class and Functional Components",detailedList:a.reactComponents},{topicName:"Props, props drilling, HOCs, Render Props",detailedList:a.reactProps},{topicName:"Lists and Keys, Event Handling and Conditional Rendering",detailedList:a.reactListsAndKeys},{topicName:"Portals in React",detailedList:a.reactPortals},{topicName:"Data Binding in React",detailedList:a.databindings}]},r=()=>(0,i.jsx)(o.default,{conceptData:s})},7127:(e,n,t)=>{t.r(n),t.d(n,{databindings:()=>c,reactComponents:()=>a,reactConcepts:()=>o,reactListsAndKeys:()=>s,reactPortals:()=>r,reactProps:()=>i});const o=[{contentName:"1. React",contentList:["It is a JavaScript library for building fast, interactive, and scalable user interfaces (UI), primarily for web applications.","It is declarative, efficient, and flexible.","It is component-based, meaning the UI is split into independent, reusable pieces."]},{contentName:"a. Advantages",contentList:['<span class="semibold_italic">Component-Based Architecture \u2192</span> Reusable components make development faster and code more maintainable.','<span class="semibold_italic">Fast Rendering with Virtual DOM \u2192</span> React updates only the necessary parts of the UI, improving performance.','<span class="semibold_italic">Unidirectional Data Flow \u2192</span> Ensures predictable state management, reducing bugs and making debugging easier.','<span class="semibold_italic">Rich Ecosystem & Community Support \u2192</span> Huge open-source support with libraries like Redux, React Query, and Material UI.','<span class="semibold_italic">Easy to Learn & Use \u2192</span> JSX simplifies UI development, making React beginner-friendly.','<span class="semibold_italic">Cross-Platform Development \u2192</span> React Native allows code reuse for mobile apps (iOS & Android).'],padLeft:!0},{contentName:"b. Limitations",contentList:['<span class="semibold_italic">Not a Full Framework:</span> Only handles UI, needs React Router for navigation, Redux/Context API for state, API handling etc.','<span class="semibold_italic">SEO Issues:</span> React uses client-side rendering, which can hurt SEO. Solution: Use Next.js for SSR.','<span class="semibold_italic">Frequent Updates:</span> React evolves quickly (e.g., Class Components \u2192 Hooks), requiring constant learning.','<span class="semibold_italic">Prop Drilling & Complex State:</span> Passing data deep in components is painful; needs Context API, Redux, or Zustand.','<span class="semibold_italic">Not Ideal for Small/Static Apps:</span> Lightweight alternatives like Svelte, Vue, or Astro are better in some cases.'],padLeft:!0},{contentName:"2. JSX (JavaScript XML)",contentList:["It is a syntax extension for JavaScript, similar to XML/HTML, used with React to describe UI components.","It allows writing HTML in React and JavaScript code in the same file.","It is not a necessity but a convention for writing React components."]},{contentName:"a. Advantages",contentList:['<span class="semibold_italic">Easy to Write & Read:</span> Combines HTML & JS, making code more readable and maintainable.','<span class="semibold_italic">Prevents Injection Attacks:</span> Automatically escapes user inputs, preventing XSS attacks.','<span class="semibold_italic">Faster Development:</span> Reduces context switching between HTML and JS, improving productivity.'],padLeft:!0},{contentName:"b. How JSX works?",contentList:["JSX is transpiled to JavaScript using Babel, converting HTML-like syntax to React.createElement() calls.","React.createElement() creates a virtual DOM object (React Element) for each JSX tag.","React then updates the actual DOM based on the virtual DOM changes."],padLeft:!0},{contentName:"3. Virtual DOM",contentList:["It is a lightweight copy of the actual DOM, used by React to improve performance.","React compares the virtual DOM with the actual DOM and updates only the changed parts.","It reduces the number of DOM manipulations, improving rendering speed."]},{contentName:"4. Reconciliation Process",contentList:["It is is the process React uses to update the Real DOM efficiently when the state or props of a component change. Instead of re-rendering the entire UI, React compares the new Virtual DOM with the previous one and updates only the changed parts in the actual DOM."]},{contentName:"a. How Virtual DOM Updates work? (Reconciliation Process)",contentList:['<span class="semibold_italic">Render Phase:</span> When the UI changes, React creates a new virtual DOM tree.','<span class="semibold_italic">Diffing Phase:</span> React compares the new virtual DOM with the previous one using the diffing algorithm to find the changes.','<span class="semibold_italic">Reconciliation Phase:</span> Instead of updating the actual DOM directly, React updates only the changed parts, improving performance.'],contentCodeBlock:'function TextUpdater() {\n  const [text, setText] = useState("Hello, world!");\n\n  const updateText = () => {\n    setText("Hello, React!");\n  };\n\n  return (\n    <div>\n      <p>{text}</p>\n      <button onClick={updateText}>Change Text</button>\n    </div>\n  );\n}\n\n/*\n  How This Works (Step-by-Step)\n\n  1. Initial Render:\n     - React creates a Virtual DOM for the component with <p>Hello, world!</p>.\n\n  2. State Update (onClick Event):\n     - The button is clicked, updating the state to "Hello, React!".\n     - A new Virtual DOM tree is created with <p>Hello, React!</p>.\n\n  3. Diffing (Comparing Old vs. New Virtual DOM):\n     - React detects that only the text inside <p> has changed.\n\n  4. Reconciliation (Efficient Update to Real DOM):\n     - Instead of re-rendering the entire <p> element, React updates only the text node inside.\n*/',padLeft:!0},{contentName:"5. Difference with Real DOM & Shadow DOM",contentTable:{headers:["Features","Virtual DOM","Real DOM","Shadow DOM"],rows:[["Definition","A lightweight copy of the Real DOM used by React to track the changes efficiently before updating the Real DOM.","The actual browser-rendered HTML structure that users interact with. ","A separate, encapsulated DOM inside an element (mostly used in Web Components) to prevent style and script conflicts."],["Performance","Faster updates due to minimal DOM manipulations.","Slower updates as it directly interacts with the browser and whole repaints happen.","Improves performance by keeping styles and elements scoped to a single component."],["Rendering","Creates a virtual tree of React elements that mirrors the actual DOM.","Directly renders the HTML structure on the browser.","Renders the DOM inside a shadow root, isolated from the main document."],["Manipulation","React compares old and new VDOM, updating only the necessary parts in the Real DOM.","Any change directly affects the page, causing a reflow and repaint.","Elements inside a Shadow DOM are independent of the main DOM."],["Use Case","React uses VDOM to improve performance and reduce re-renders.","Traditional websites and applications that don\u2019t use a framework.","Web Components that need encapsulation and reusability."]]}}],a=[{contentName:"1. Components in React",contentList:["In React, components are the building blocks of the user interface.","They\u2019re essentially reusable, independent pieces of code that define how a part of the UI should look and behave.","Think of them like Lego bricks\u2014you can create small pieces like a button or a card and then combine them to build complex interfaces.","Each component can manage its own state, receive data through props, and render UI based on that data.","In React, components can be created in two different ways: Class Components and Functional Components."]},{contentName:"a. Class Components",contentList:["Class components are ES6 classes that extend from React.Component and can hold their own state.","They have a render() method that returns the component\u2019s UI based on the current state and props.","Class components can also have lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount.","Before React 16.8, class components were the primary way to create components in React.","After the introduction of Hooks in React 16.8, functional components became the preferred way to create components due to their simplicity and reusability.","Now functional components can also use state and lifecycle methods, making class components less common."],contentCodeBlock:'import React, { Component } from "react";\n\nclass Counter extends Component {\n  state = {\n    count: 0,\n  };\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n\n/*\n  How This Works\n\n  1. Initial Render:\n     - The component renders with count: 0 and a button to increment.\n\n  2. State Update (onClick Event):\n     - The button is clicked, updating the state to count: 1.\n     - React re-renders the component with the new state.\n*/',padLeft:!0},{contentName:"b. Functional Components",contentList:["Functional components are JavaScript functions that return JSX.","They are simpler, shorter, and easier to read than class components.","In traditional functional components, you couldn\u2019t use state or lifecycle methods, making them limited in functionality.","With the introduction of Hooks in React 16.8, functional components can now use state and lifecycle methods, making them more powerful and versatile."],contentCodeBlock:'import React, { useState } from "react";\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;\n\n/*\n  How This Works\n\n  1. Initial Render:\n     - The component renders with count: 0 and a button to increment.\n\n  2. State Update (onClick Event):\n     - The button is clicked, updating the state to count: 1.\n     - React re-renders the component with the new state.\n*/',padLeft:!0},{contentName:"2. Why not use Class Components?",contentList:["Class components are more verbose and harder to read than functional components.","They require more boilerplate code, making them slower to write and maintain.","Class components don\u2019t optimize performance as well as functional components.","Functional components are easier to test and debug than class components.","Functional components are more reusable and composable than class components."]},{contentName:"3. When to use what?",contentList:["If you\u2019re starting a new project, use functional components with Hooks for better code quality and maintainability.","If you're working on legacy code or a project that uses class components, continue using them until you can refactor to functional components.","Functional components are the future of React and are recommended for all new projects."]},{contentName:"4. Difference between Class & Functional Components",contentTable:{headers:["Features","Class Components","Functional Components"],rows:[["Definition","ES6 classes that extend from React.Component.","JavaScript functions that return JSX."],["State & Lifecycle","Can hold state and use lifecycle methods.","Can use state and lifecycle methods with Hooks."],["Code Length","More verbose and requires more boilerplate code.","Shorter, simpler, and easier to read."],["Performance","Slower performance due to class bindings and lifecycle methods.","Faster performance due to fewer bindings and lifecycle methods."],["Reusability","Less reusable and composable.","More reusable and composable."],["Testing","Harder to test and debug.","Easier to test and debug."],["Recommended Use","Use for legacy code or projects that require class components.","Use for new projects or projects that can be refactored."]]}}],i=[{contentName:"1. Props",contentList:["Props (short for properties) are read-only inputs passed from a parent component to a child component (similar like function arguments).","They allow components to be reusable and dynamic by sending data like strings, numbers, objects, and functions.","Props define how the child components should render based on the data passed from the parent components.","Props are immutable because React follows a unidirectional data flow (one-way binding). The parent controls the data, and the child cannot modify it, ensuring better predictability and maintainability."],contentCodeBlock:"function ChildComponent({ name, age }) {\n  return (\n    <>\n      <p>Name: {name}</p>\n      <p>Age: {age}</p>\n    </>\n  );\n}\n\nfunction ParentComponent() {\n  return <ChildComponent name=\"John Doe\" age={30} />;\n}\n\n/*\n  How This Works\n  1. ParentComponent: Passes the props 'name' and 'age' to ChildComponent.\n  2. ChildComponent: Receives the props and renders them in the JSX.\n*/"},{contentName:"a. Passing Props",contentList:["Props are passed from parent to child components using attributes.","Props are passed as key-value pairs, where the key is the prop name and the value is the data to be passed."],padLeft:!0},{contentName:"b. Destructuring Props",contentList:["Props can be destructured inside the child component to access the individual prop values directly.","Destructuring makes the code cleaner and more readable by extracting the props into separate variables."],padLeft:!0,contentCodeBlock:"// Without Destructuring\nfunction ChildComponent(props) {\n  return (\n    <>\n      <p>Name: {props.name}</p>\n      <p>Age: {props.age}</p>\n    </>\n  );\n\n// With Destructuring\nfunction ChildComponent({ name, age }) {\n  return (\n    <>\n      <p>Name: {name}</p>\n      <p>Age: {age}</p>\n    </>\n  );\n}"},{contentName:"c. Default Props",contentList:["Default props are used to set default values for props in case they are not passed from the parent component.","They help in handling undefined props gracefully and prevent errors."],padLeft:!0,contentCodeBlock:'function ChildComponent({ name = "Anonymous", age = 0 }) {\n  return (\n    <>\n      <p>Name: {name}</p>\n      <p>Age: {age}</p>\n    </>\n  );\n}'},{contentName:"d. Children Props (Passing Components as Props: Render Props Pattern)",contentList:["The children prop is a special prop that allows passing JSX elements or text or Components as children to another component.","It is useful for creating reusable components that wrap other components or elements.","The children prop can be used to create higher-order components (HOCs) or render props patterns.","It is commonly used for components like modals, tooltips, and cards."],padLeft:!0,contentCodeBlock:'function Card({ title, children }) {\n  return (\n    <div>\n      <h2>{title}</h2>\n      <div>{children}</div>\n    </div>\n  );\n\nfunction App() {\n  return (\n    <Card title="My Card">\n      <p>This is the content of the card.</p>\n    </Card>\n  );\n}'},{contentName:"e. Spread Operator with Props",contentList:["The spread operator (...) can be used to pass multiple props to a component without explicitly defining each prop.","It helps in passing all the props of an object or component to another component."],padLeft:!0,contentCodeBlock:'const user = {\n  name: "John Doe",\n  age: 30,\n};\n\nfunction Profile({ name, age }) {\n  return (\n    <>\n      <p>Name: {name}</p>\n      <p>Age: {age}</p>\n    </>\n  );\n\nfunction App() {\n  return <Profile {...user} />;\n}'},{contentName:"2. Prop Types and Validation",contentList:["PropTypes is a library used for type-checking the props passed to a component.","It helps in validating the props passed from the parent component to ensure they are of the correct type.","Common PropTypes include string, number, boolean, array, object, function, etc.","PropTypes are defined as static properties on the component."],contentCodeBlock:'import PropTypes from "prop-types";\n\nfunction ChildComponent({ name, age }) {\n  return (\n    <>\n      <p>Name: {name}</p>\n      <p>Age: {age}</p>\n    </>\n  );\n\nChildComponent.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number.isRequired,\n};'},{contentName:"3. How to Update Props? (trigger events from child to parent)",contentList:["Props are immutable and cannot be changed directly by the child component.","To update props, you can pass callback functions as props from the parent component to the child component.","The child component can call the callback function to trigger an event in the parent component, updating the props."],contentCodeBlock:'function ParentComponent() {\n  const [name, setName] = useState("John Doe");\n\n  const updateName = () => {\n    setName("David Smith");\n  }\n\n  return (\n    <>\n      <ChildComponent name={name} updateName={updateName} />\n    </>\n  );\n\nfunction ChildComponent({ name, updateName }) {\n  return (\n    <>\n      <p>Name: {name}</p>\n      <button onClick={updateName}>Update Name</button>\n    </>\n  );\n}'},{contentName:"4. What is props drilling? How to avoid it?",contentList:["Props drilling is the process of passing props through multiple levels of components to reach a deeply nested child component.","It can make the code harder to maintain and debug, as props have to be passed through intermediary components.","To avoid props drilling, use React Context API or state management libraries like Redux or MobX."],contentCodeBlock:'// Using Context API\nconst UserContext = React.createContext();\n\nfunction ParentComponent() {\n  const user = { name: "John Doe", age: 30 };\n\n  return (\n    <UserContext.Provider value={user}>\n      <ChildComponent />\n    </UserContext.Provider>\n  );\n\nfunction ChildComponent() {\n  const user = useContext(UserContext);\n  return (\n    <>\n      <p>Name: {user.name}</p>\n      <p>Age: {user.age}</p>\n    </>\n  );'},{contentName:"5. How do you prevent unnecessary re-renders due to props?",contentList:["To prevent unnecessary re-renders due to props changes, use React.memo() for functional components and PureComponent for class components.","React.memo() is a higher-order component that memoizes the component based on its props, preventing re-renders if the props haven't changed.","PureComponent is a class component that does a shallow comparison of props and state to prevent re-renders if they haven't changed."],contentCodeBlock:"const ChildComponent = React.memo(({ name }) => {\n  return <p>Name: {name}</p>;\n});"},{contentName:"6. How to handle dynamic props in React?",contentList:["To handle dynamic props in React, you can use JavaScript expressions to pass props based on conditions.","You can also use the spread operator (...) to pass multiple dynamic props to a component.","Dynamic props help in creating reusable components that can render different content based on the data passed.","Example: A profile component that renders different user profiles based on the user data passed as props."]},{contentName:"7. Higher-Order Components (HOCs)",contentList:["Higher-Order Components (HOCs) are functions that take a component and return a new component with additional functionality.","They are used to share code between components, add new props, or modify the behavior of existing components.","HOCs are a common pattern in React for code reuse, logic abstraction, and enhancing components with new features.","They allow adding common functionality to multiple components without repeating code.","HOCs are a flexible and powerful pattern for enhancing components in React applications.","Example: A withLoading HOC that shows a loading spinner while data is being fetched."],contentCodeBlock:"function withLoading(Component) {\n  return function WithLoadingComponent({ isLoading, ...props }) {\n    if (isLoading) return <Spinner />;\n    return <Component {...props} />;\n  \n  function Profile({ user }) {\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>{user.bio}</p>\n    </div>;\n  \n  const ProfileWithLoading = withLoading(Profile);\n  \n  function App() {\n    const isLoading = true; // Simulating loading state\n    return <ProfileWithLoading user={user} isLoading={isLoading} />;\n  }"},{contentName:"8. Render Props Pattern",contentList:["The Render Props pattern is a technique for sharing code between React components using a prop whose value is a function.","It allows components to share logic and data with other components by passing a function as a child prop without repeating the logic.","The child component can then call the function to access the shared logic or data from the parent component.","The Render Props pattern is commonly used for code reuse and component composition in React applications.","It provides a flexible way to pass data and functionality between components.","They help in separating concerns and keeping components focused on their specific tasks.","Example: One component that fetches data and another component that renders the fetched data using the Render Props pattern."],contentCodeBlock:"function DataFetcher({ render }) {\n  const data = fetchData(); // Fetch data from API\n  return render(data);\n}\n\nfunction Profile({ user }) {\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>{user.bio}</p>\n    </div>;\n}\n\nfunction App() {\n  return (\n    <DataFetcher\n      render={(data) => (\n        <Profile user={data} />\n      )}\n    />\n  );\n}"},{contentName:"9. When to use HOCS vs Render Props?",contentList:["Use Higher-Order Components (HOCs) when you need to share common logic between multiple components.","Use Render Props when you need to share data or functionality between components using a prop whose value is a function.","HOCs are useful for code reuse and logic abstraction, while Render Props are useful for data sharing and component composition.","Both patterns are powerful and flexible ways to enhance components in React applications."],contentCodeBlock:"// Example: Use HOCs for sharing common logic\nconst ProfileWithLoading = withLoading(Profile);\n\n// Example: Use Render Props for sharing data\n<DataFetcher\n  render={(data) => (\n    <Profile user={data} />\n  )}\n/>"}],s=[{contentName:"1. Lists and Keys in React",contentList:["Lists ares used in React to render multiple elements dynamically based on an array of data. (Ex: users, cart items, products, etc.)","A key is an unique identifier assigned to each element in a list to help React identify which items have changed, added, or removed.","Keys help React optimize rendering by reducing re-renders and improving performance.","Keys should be unique, stable, and consistent across renders to ensure proper reconciliation and avoid bugs.","If keys are not unique or not provided, React may re-render all the items, causing performance issues. (such as flickering, data loss, inefficient updates, etc.)"],contentCodeBlock:"function ListComponent({ items }) {\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={item.id}>{item.name}</li>\n      )}\n    </ul>\n  );\n}"},{contentName:"a. Why use Keys? How they work while updating lists?",contentList:["Keys help React identify which items have changed, added, or removed in a list.","They improve rendering performance by reducing re-renders and optimizing updates.","Keys are essential for efficient list rendering and proper reconciliation in React applications.","When an item is added, removed, or reordered in a list, React uses keys to determine the changes and update only the necessary parts of the UI.","For example, when a new item is added to a list, React compares the keys of the new list with the old list to identify the added item and render it without re-rendering the entire list."],padLeft:!0},{contentName:"b. Best Practices for Keys",contentList:["Keys should be unique, stable, and consistent across renders to ensure proper reconciliation.","Use string or number keys for better performance and predictability. (like database IDs, UUIDs, etc.)","For dynamic lists don't use index as keys, as it can cause issues when items are added, removed, or reordered.","Keys should be assigned to the top-level element inside the map function to ensure proper reconciliation.","If the list items have unique IDs, use them as keys. Otherwise, generate unique keys using libraries like uuid."],padLeft:!0},{contentName:"2. Event Handling in React",contentList:["Event handling in React is how the UI responds to user interactions like clicks, keypresses, form submissions, etc.","Event handling in React is similar to handling events in HTML, but with camelCase event names.","Events are passed as functions (event handlers) to JSX elements and triggered when the event occurs.","Common events include onClick, onChange, onSubmit, onMouseOver, etc.","Event handlers receive an event object that contains information about the event (like target, type, etc.).","To prevent the default behavior of an event (like form submission or link click), use event.preventDefault()."],contentCodeBlock:'function ButtonComponent() {\n  const handleClick = () => {\n    alert("Button Clicked!");\n}\n\nreturn <button onClick={handleClick}>Click Me</button>;\n}'},{contentName:"a. Event Object in React",contentList:["The event object contains information about the event like target, type, key, etc.","It is automatically passed to the event handler function when an event occurs.","You can access event properties like event.target.value, event.type, event.key, etc.","The event object can be used to prevent the default behavior of an event using event.preventDefault()."],padLeft:!0},{contentName:"b. Preventing Default Behavior",contentList:["To prevent the default behavior of an event (like form submission which causes a page reload, or link click which navigates to a new page), use event.preventDefault().","It stops the default action of the event from occurring.","Preventing default behavior is useful for handling form submissions, link clicks, and other user interactions."],padLeft:!0,contentCodeBlock:'function FormComponent() {\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    alert("Form Submitted!");\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input type="text" />\n      <button type="submit">Submit</button>\n    </form>\n  );\n}'},{contentName:"c. Synthetic Events in React",contentList:["A SyntheticEvent is React\u2019s wrapper around native browser events that ensures cross-browser compatibility and performance optimization.","Synthetic events are similar to native events but have some differences like event pooling, asynchronous behavior, and automatic cleanup.","They are automatically cleaned up after the event handler has finished, preventing memory leaks.","Synthetic events are used to handle events in React components and provide a consistent interface across different browsers.","Event pooling is a technique used by React to reuse event objects, improving performance and reducing memory usage.","Events when used in setTimeout or asynchronous functions, the event object may be null or undefined due to the asynchronous nature of React.","To access event properties in asynchronous functions, store the event object in a variable before using it."],padLeft:!0},{contentName:"3. Conditional Rendering in React",contentList:["Conditional rendering is used to show or hide elements based on a condition in React components.","You can use JavaScript expressions like if-else, ternary operators, and logical && or || operators for conditional rendering.","Common use cases for conditional rendering include showing loading spinners, error messages, or rendering components based on user authentication.","Conditional rendering helps in creating dynamic and interactive user interfaces in React applications."],contentCodeBlock:"function DataComponent() {\n  return <div>Data Loaded!</div>;\n}\n\nfunction Spinner() {\n  return <div>Loading...</div>;\n}\n\nfunction Error({ message }) {\n  return <div>Error: {message}</div>;\n}\n\n// Using Ternary Operator\nreturn isLoading ? <Spinner /> : <DataComponent />;\n\n// Using Logical && Operator\nreturn error && <Error message={error} />;\n\n// Using If-Else Statement\nif (isLoading) {\n  return <Spinner />;\n} else if (error) {\n  return <Error message={error} />;\n} else {\n  return <DataComponent />;\n}"}],r=[{contentName:"1. Portals in React",contentList:["Portals in React provide a way to render children outside the DOM hierarchy of the parent component.","They allow rendering components into a different part of the DOM, like modals, popovers, tooltips, or overlays.","Portals help in creating UI components that need to break out of the parent container or have z-index stacking issues.","Portals are useful for creating overlays, modals, tooltips, and other components that need to be rendered outside the normal flow of the DOM."],contentCodeBlock:'function Modal({ children }) {\n  return ReactDOM.createPortal(\n    children,\n    document.getElementById("modal-root")\n  );\n\nfunction App() {\n  return (\n    <div>\n      <h1>App Content</h1>\n      <Modal>\n        <p>Modal Content</p>\n      </Modal>\n    </div>\n  );\n}'},{contentName:"a. How Portals work?",contentList:["Portals use ReactDOM.createPortal() to render children into a different part of the DOM.","The createPortal() function takes two arguments: the children to render and the DOM element to render them into.","The children are rendered outside the normal DOM hierarchy of the parent component, allowing them to break out of the parent container.","Real time examples: payment modals, tooltips, popovers, lightboxes, etc."],padLeft:!0}],c=[{contentName:"1. Data Bindings in Frontend",contentList:["It is a technique to connect data from the model (data source) to the view (UI) in frontend applications, ensuring that changes in data automatically reflect in the UI and vice versa.","Data bindings help in creating dynamic and interactive user interfaces by synchronizing the data and UI components.","Model-view-controller (MVC) and model-view-viewmodel (MVVM) are common design patterns that use data bindings to connect the data and UI components.","Data bindings are used in frontend frameworks like Angular, React, Vue, and libraries like Knockout.js to create reactive and responsive applications.","There are two types of data bindings: one-way data binding (from model to view) and two-way data binding (between model and view)."]},{contentName:"a. Data Flow in Frontend Applications",contentList:["Data flows from the model (data source) to the view (UI) in frontend applications.","When the data changes in the model, the view is updated to reflect the changes.","Data bindings ensure that the UI components are always in sync with the data, providing a reactive and responsive user interface.","Data flow is essential for creating dynamic and interactive applications that respond to user inputs and changes in data.","The data flows from the model to the view or vice versa, and sometimes both ways depending on the type of data binding used."],padLeft:!0},{contentName:"2. One-Way Data Binding (Single source of truth)",contentList:["One-way data binding is also known as unidirectional data flow.","It is a pattern where data flows in a single direction, either from the model to the view or from the view to the model, but not both simultaneously.","Changes in the model automatically update the view, but changes in the view do not affect the model directly.","This approach is simpler and more predictable compared to two-way data binding, as it enforces a clear flow of data and reduces the risk of unintended side effects.","<b>Example (React):</b> A component state or props are used to render the UI. When the state or props change, the React's rendering mechanism updates the UI components accordingly. <b>(This is model to view binding)</b>"]},{contentName:"a. Advantages of One-Way Data Binding",contentList:["Simpler and more predictable data flow.","Reduces the risk of unintended side effects.","Easier to debug and maintain.","Enforces a clear separation of concerns between data and UI."],padLeft:!0},{contentName:"b. View to Model in One-Way Data Binding",contentList:["The most commonly used way in One-Way Data Binding is model to view binding, where the data flows from the model to the view.","In this approach, changes in the model automatically update the view, but changes in the view do not affect the model directly.","To make changes in the model, from the view (UI), changes made in the UI are captured by event handlers (user interactions in the view), which then update the model accordingly.","However, changes to the model, do not automatically update the view, but the view is updated when the model changes are detected."],padLeft:!0},{contentName:"3. Two-Way Data Binding (Bi-directional data flow)",contentList:["Two-way data binding is a pattern where data flows in both directions, from the model to the view and vice versa.","This means that changes in the model automatically update the view, and changes in the view update the model as well.","Two-way data binding is commonly used in frameworks like Angular, where changes in the UI components are automatically reflected in the model and vice versa.","While two-way data binding simplifies development by automatically synchronizing the data and UI, it can also lead to complex data flows and unintended side effects."]},{contentName:"a. Advantages of Two-Way Data Binding",contentList:["Automatically synchronizes data and UI components.","Simplifies development by reducing the need for manual data updates.","Provides a more interactive and responsive user interface.","Commonly used in frameworks like Angular for rapid development."],padLeft:!0},{contentName:"4. How do you achieve Two-Way Data Binding in React?",contentList:["In React, two-way data binding is not natively supported like in Angular or Vue.","React follows a unidirectional data flow by default, where data flows from the model to the view.","However, you can achieve two-way data binding in React by combining state management with event handling. This approach allows you to keep the UI in sync with the data and vice versa.","<b>Example:</b> Using controlled components in React to create two-way data binding by updating the state based on user inputs and reflecting the state changes in the UI."],contentCodeBlock:"function MyComponent() {\n  const [name, setName] = useState('John'); // State to manage the input value\n\n  const handleChange = (event) => {\n    setName(event.target.value); // Update the state when the input changes\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={name} // Bind the input value to the state\n        onChange={handleChange} // Handle changes to update the state\n      />\n      <p>Hello, {name}!</p>\n    </div>\n  );\n}\n  \n// How it works:\na. The input value is bound to the state using value={name}.\nb. The handleChange function updates the state when the input changes.\nc. The state change triggers a re-render, updating the UI with the new value.\nd. This way the data model and the UI are kept in sync."},{contentName:"5. When to use One-Way vs Two-Way Data Binding?",contentList:["Use one-way data binding (unidirectional data flow) for simpler and more predictable data flows.","One-way data binding enforces a clear separation of concerns between data and UI, reducing the risk of unintended side effects.","Use two-way data binding for rapid development and interactive user interfaces where changes in the UI should automatically update the data and vice versa.","Two-way data binding simplifies development by automatically synchronizing the data and UI components, but can lead to complex data flows and unintended side effects."]}]},2347:(e,n,t)=>{t.d(n,{A:()=>y});var o=t(5043),a=t(8387),i=t(4984),s=t(8812),r=t(9172),c=t(1406);function d(e){const{sx:n,...t}=e,{systemProps:o,otherProps:a}=(e=>{const n={systemProps:{},otherProps:{}},t=e?.theme?.unstable_sxConfig??c.A;return Object.keys(e).forEach((o=>{t[o]?n.systemProps[o]=e[o]:n.otherProps[o]=e[o]})),n})(t);let i;return i=Array.isArray(n)?[o,...n]:"function"===typeof n?function(){const e=n(...arguments);return(0,r.Q)(e)?{...o,...e}:o}:{...o,...n},{...a,sx:i}}var l=t(3693),p=t(579);var h=t(9386),m=t(638),u=t(3375);const f=(0,t(2532).A)("MuiBox",["root"]),g=(0,m.A)(),v=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{themeId:n,defaultTheme:t,defaultClassName:r="MuiBox-root",generateClassName:c}=e,h=(0,i.Ay)("div",{shouldForwardProp:e=>"theme"!==e&&"sx"!==e&&"as"!==e})(s.A);return o.forwardRef((function(e,o){const i=(0,l.A)(t),{className:s,component:m="div",...u}=d(e);return(0,p.jsx)(h,{as:m,ref:o,className:(0,a.A)(s,c?c(r):r),theme:n&&i[n]||i,...u})}))}({themeId:u.A,defaultTheme:g,defaultClassName:f.root,generateClassName:h.A.generate}),y=v},9662:(e,n,t)=>{t.d(n,{A:()=>v});var o=t(5043),a=t(8387),i=t(8610),s=t(6803),r=t(2108),c=t(6262),d=t(6431),l=t(2532),p=t(2372);function h(e){return(0,p.Ay)("MuiSvgIcon",e)}(0,l.A)("MuiSvgIcon",["root","colorPrimary","colorSecondary","colorAction","colorError","colorDisabled","fontSizeInherit","fontSizeSmall","fontSizeMedium","fontSizeLarge"]);var m=t(579);const u=(0,r.Ay)("svg",{name:"MuiSvgIcon",slot:"Root",overridesResolver:(e,n)=>{const{ownerState:t}=e;return[n.root,"inherit"!==t.color&&n[`color${(0,s.A)(t.color)}`],n[`fontSize${(0,s.A)(t.fontSize)}`]]}})((0,c.A)((e=>{let{theme:n}=e;return{userSelect:"none",width:"1em",height:"1em",display:"inline-block",flexShrink:0,transition:n.transitions?.create?.("fill",{duration:(n.vars??n).transitions?.duration?.shorter}),variants:[{props:e=>!e.hasSvgAsChild,style:{fill:"currentColor"}},{props:{fontSize:"inherit"},style:{fontSize:"inherit"}},{props:{fontSize:"small"},style:{fontSize:n.typography?.pxToRem?.(20)||"1.25rem"}},{props:{fontSize:"medium"},style:{fontSize:n.typography?.pxToRem?.(24)||"1.5rem"}},{props:{fontSize:"large"},style:{fontSize:n.typography?.pxToRem?.(35)||"2.1875rem"}},...Object.entries((n.vars??n).palette).filter((e=>{let[,n]=e;return n&&n.main})).map((e=>{let[t]=e;return{props:{color:t},style:{color:(n.vars??n).palette?.[t]?.main}}})),{props:{color:"action"},style:{color:(n.vars??n).palette?.action?.active}},{props:{color:"disabled"},style:{color:(n.vars??n).palette?.action?.disabled}},{props:{color:"inherit"},style:{color:void 0}}]}}))),f=o.forwardRef((function(e,n){const t=(0,d.b)({props:e,name:"MuiSvgIcon"}),{children:r,className:c,color:l="inherit",component:p="svg",fontSize:f="medium",htmlColor:g,inheritViewBox:v=!1,titleAccess:y,viewBox:b="0 0 24 24",...w}=t,C=o.isValidElement(r)&&"svg"===r.type,k={...t,color:l,component:p,fontSize:f,instanceFontSize:e.fontSize,inheritViewBox:v,viewBox:b,hasSvgAsChild:C},R={};v||(R.viewBox=b);const x=(e=>{const{color:n,fontSize:t,classes:o}=e,a={root:["root","inherit"!==n&&`color${(0,s.A)(n)}`,`fontSize${(0,s.A)(t)}`]};return(0,i.A)(a,h,o)})(k);return(0,m.jsxs)(u,{as:p,className:(0,a.A)(x.root,c),focusable:"false",color:g,"aria-hidden":!y||void 0,role:y?"img":void 0,ref:n,...R,...w,...C&&r.props,ownerState:k,children:[C?r.props.children:r,y?(0,m.jsx)("title",{children:y}):null]})}));f.muiName="SvgIcon";const g=f;function v(e,n){function t(t,o){return(0,m.jsx)(g,{"data-testid":`${n}Icon`,ref:o,...t,children:e})}return t.muiName=g.muiName,o.memo(o.forwardRef(t))}},3693:(e,n,t)=>{t.d(n,{A:()=>c});var o=t(3216),a=t(5043),i=t(9369);const s=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const n=a.useContext(i.T);return n&&(t=n,0!==Object.keys(t).length)?n:e;var t},r=(0,o.A)();const c=function(){return s(arguments.length>0&&void 0!==arguments[0]?arguments[0]:r)}}}]);
//# sourceMappingURL=838.205497cd.chunk.js.map