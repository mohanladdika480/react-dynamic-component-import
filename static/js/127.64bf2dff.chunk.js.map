{"version":3,"file":"static/js/127.64bf2dff.chunk.js","mappings":"wNAAA,MAAMA,EAAgB,CACpB,CACEC,YAAa,WACbC,YAAa,CACX,gIACA,8CACA,sFAGJ,CACED,YAAa,gBACbC,YAAa,CACX,mJACA,uJACA,wJACA,mKACA,iIACA,0IAEFC,SAAS,GAEX,CACEF,YAAa,iBACbC,YAAa,CACX,gKACA,wIACA,mJACA,wJACA,uJAEFC,SAAS,GAEX,CACEF,YAAa,0BACbC,YAAa,CACX,2GACA,wEACA,yEAGJ,CACED,YAAa,gBACbC,YAAa,CACX,6HACA,8HACA,mIAEFC,SAAS,GAEX,CACEF,YAAa,oBACbC,YAAa,CACX,2GACA,uFACA,uEAEFC,SAAS,GAEX,CACEF,YAAa,iBACbC,YAAa,CACX,oFACA,yFACA,2EAGJ,CACED,YAAa,4BACbC,YAAa,CACX,4QAGJ,CACED,YAAa,4DACbC,YAAa,CACX,gHACA,gKACA,wKAEFE,iBAAkB,q2BA+BlBD,SAAS,GAEX,CACEF,YAAa,2CACbI,aAAc,CACZC,QAAS,CAAC,WAAY,cAAe,WAAY,cACjDC,KAAM,CACJ,CACE,aACA,kHACA,wEACA,yHAEF,CACE,cACA,mDACA,sFACA,qFAEF,CACE,YACA,wEACA,sDACA,0EAEF,CACE,eACA,sFACA,sEACA,iEAEF,CACE,WACA,gEACA,yEACA,+DAOJC,EAAkB,CACtB,CACEP,YAAa,yBACbC,YAAa,CACX,sEACA,yHACA,6IACA,yGACA,2GAGJ,CACED,YAAa,sBACbC,YAAa,CACX,kGACA,yGACA,yHACA,0FACA,8JACA,4GAEFE,iBAAkB,6qBAiClBD,SAAS,GAEX,CACEF,YAAa,2BACbC,YAAa,CACX,kEACA,uEACA,gIACA,yJAEFE,iBAAkB,ojBAyBlBD,SAAS,GAEX,CACEF,YAAa,mCACbC,YAAa,CACX,mFACA,gFACA,qFACA,4EACA,kFAGJ,CACED,YAAa,uBACbC,YAAa,CACX,2HACA,iJACA,4FAGJ,CACED,YAAa,sDACbI,aAAc,CACZC,QAAS,CAAC,WAAY,mBAAoB,yBAC1CC,KAAM,CACJ,CACE,aACA,gDACA,yCAEF,CACE,oBACA,4CACA,mDAEF,CACE,cACA,mDACA,yCAEF,CACE,cACA,kEACA,mEAEF,CACE,cACA,gCACA,iCAEF,CAAC,UAAW,4BAA6B,6BACzC,CACE,kBACA,iEACA,gEAOJE,EAAa,CACjB,CACER,YAAa,WACbC,YAAa,CACX,2IACA,kHACA,2GACA,6MAEFE,iBAAkB,gZAmBpB,CACEH,YAAa,mBACbC,YAAa,CACX,qEACA,+GAEFC,SAAS,GAEX,CACEF,YAAa,yBACbC,YAAa,CACX,sGACA,2GAEFC,SAAS,EACTC,iBAAkB,8TAmBpB,CACEH,YAAa,mBACbC,YAAa,CACX,gHACA,wEAEFC,SAAS,EACTC,iBAAkB,wJASpB,CACEH,YACE,wEACFC,YAAa,CACX,+HACA,wFACA,mGACA,wEAEFC,SAAS,EACTC,iBAAkB,uQAgBpB,CACEH,YAAa,gCACbC,YAAa,CACX,qHACA,qFAEFC,SAAS,EACTC,iBAAkB,2OAiBpB,CACEH,YAAa,+BACbC,YAAa,CACX,iFACA,4GACA,kFACA,gEAEFE,iBAAkB,yRAepB,CACEH,YACE,gEACFC,YAAa,CACX,6EACA,8GACA,uHAEFE,iBAAkB,maAsBpB,CACEH,YAAa,8CACbC,YAAa,CACX,iIACA,iHACA,oGAEFE,iBAAkB,gbAqBpB,CACEH,YAAa,6DACbC,YAAa,CACX,6IACA,+IACA,uIAEFE,iBAAkB,yFAIpB,CACEH,YAAa,2CACbC,YAAa,CACX,0GACA,4FACA,iHACA,8GAGJ,CACED,YAAa,oCACbC,YAAa,CACX,+HACA,gHACA,oHACA,wFACA,2FACA,wFAEFE,iBAAkB,ugBAmBpB,CACEH,YAAa,0BACbC,YAAa,CACX,4HACA,wIACA,+GACA,4GACA,gFACA,2FACA,gIAEFE,iBAAkB,0XAuBpB,CACEH,YAAa,uCACbC,YAAa,CACX,sGACA,2HACA,kIACA,6FAEFE,iBAAkB,iOAahBM,EAAoB,CACxB,CACET,YAAa,6BACbC,YAAa,CACX,sIACA,uIACA,uFACA,+GACA,qKAEFE,iBAAkB,qKAUpB,CACEH,YAAa,uDACbC,YAAa,CACX,kFACA,oFACA,mGACA,kJACA,6LAEFC,SAAS,GAEX,CACEF,YAAa,6BACbC,YAAa,CACX,gGACA,wGACA,iHACA,4GACA,mHAEFC,SAAS,GAEX,CACEF,YAAa,6BACbC,YAAa,CACX,sHACA,iGACA,uGACA,uEACA,8GACA,iHAEFE,iBAAkB,+JAQpB,CACEH,YAAa,2BACbC,YAAa,CACX,qFACA,iFACA,uFACA,0GAEFC,SAAS,GAEX,CACEF,YAAa,iCACbC,YAAa,CACX,0KACA,2DACA,kHAEFC,SAAS,EACTC,iBAAkB,uRAcpB,CACEH,YAAa,+BACbC,YAAa,CACX,+IACA,4IACA,mGACA,+HACA,sHACA,+IACA,QAGJ,CACED,YAAa,oCACbC,YAAa,CACX,mGACA,gIACA,qJACA,0GAEFE,iBAAkB,ohB","sources":["components/React/CoreReact/CoreReactConceptsData.js"],"sourcesContent":["const reactConcepts = [\r\n  {\r\n    contentName: \"1. React\",\r\n    contentList: [\r\n      `It is a JavaScript library for building fast, interactive, and scalable user interfaces (UI), primarily for web applications.`,\r\n      `It is declarative, efficient, and flexible.`,\r\n      `It is component-based, meaning the UI is split into independent, reusable pieces.`,\r\n    ],\r\n  },\r\n  {\r\n    contentName: \"a. Advantages\",\r\n    contentList: [\r\n      `<span class=\"semibold_italic\">Component-Based Architecture →</span> Reusable components make development faster and code more maintainable.`,\r\n      `<span class=\"semibold_italic\">Fast Rendering with Virtual DOM →</span> React updates only the necessary parts of the UI, improving performance.`,\r\n      `<span class=\"semibold_italic\">Unidirectional Data Flow →</span> Ensures predictable state management, reducing bugs and making debugging easier.`,\r\n      `<span class=\"semibold_italic\">Rich Ecosystem & Community Support →</span> Huge open-source support with libraries like Redux, React Query, and Material UI.`,\r\n      `<span class=\"semibold_italic\">Easy to Learn & Use →</span> JSX simplifies UI development, making React beginner-friendly.`,\r\n      `<span class=\"semibold_italic\">Cross-Platform Development →</span> React Native allows code reuse for mobile apps (iOS & Android).`,\r\n    ],\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"b. Limitations\",\r\n    contentList: [\r\n      `<span class=\"semibold_italic\">Not a Full Framework:</span> Only handles UI, needs React Router for navigation, Redux/Context API for state, API handling etc.`,\r\n      `<span class=\"semibold_italic\">SEO Issues:</span> React uses client-side rendering, which can hurt SEO. Solution: Use Next.js for SSR.`,\r\n      `<span class=\"semibold_italic\">Frequent Updates:</span> React evolves quickly (e.g., Class Components → Hooks), requiring constant learning.`,\r\n      `<span class=\"semibold_italic\">Prop Drilling & Complex State:</span> Passing data deep in components is painful; needs Context API, Redux, or Zustand.`,\r\n      `<span class=\"semibold_italic\">Not Ideal for Small/Static Apps:</span> Lightweight alternatives like Svelte, Vue, or Astro are better in some cases.`,\r\n    ],\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"2. JSX (JavaScript XML)\",\r\n    contentList: [\r\n      `It is a syntax extension for JavaScript, similar to XML/HTML, used with React to describe UI components.`,\r\n      `It allows writing HTML in React and JavaScript code in the same file.`,\r\n      `It is not a necessity but a convention for writing React components.`,\r\n    ],\r\n  },\r\n  {\r\n    contentName: \"a. Advantages\",\r\n    contentList: [\r\n      `<span class=\"semibold_italic\">Easy to Write & Read:</span> Combines HTML & JS, making code more readable and maintainable.`,\r\n      `<span class=\"semibold_italic\">Prevents Injection Attacks:</span> Automatically escapes user inputs, preventing XSS attacks.`,\r\n      `<span class=\"semibold_italic\">Faster Development:</span> Reduces context switching between HTML and JS, improving productivity.`,\r\n    ],\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"b. How JSX works?\",\r\n    contentList: [\r\n      `JSX is transpiled to JavaScript using Babel, converting HTML-like syntax to React.createElement() calls.`,\r\n      `React.createElement() creates a virtual DOM object (React Element) for each JSX tag.`,\r\n      `React then updates the actual DOM based on the virtual DOM changes.`,\r\n    ],\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"3. Virtual DOM\",\r\n    contentList: [\r\n      `It is a lightweight copy of the actual DOM, used by React to improve performance.`,\r\n      `React compares the virtual DOM with the actual DOM and updates only the changed parts.`,\r\n      `It reduces the number of DOM manipulations, improving rendering speed.`,\r\n    ],\r\n  },\r\n  {\r\n    contentName: \"4. Reconciliation Process\",\r\n    contentList: [\r\n      `It is is the process React uses to update the Real DOM efficiently when the state or props of a component change. Instead of re-rendering the entire UI, React compares the new Virtual DOM with the previous one and updates only the changed parts in the actual DOM.`,\r\n    ],\r\n  },\r\n  {\r\n    contentName: \"a. How Virtual DOM Updates work? (Reconciliation Process)\",\r\n    contentList: [\r\n      `<span class=\"semibold_italic\">Render Phase:</span> When the UI changes, React creates a new virtual DOM tree.`,\r\n      `<span class=\"semibold_italic\">Diffing Phase:</span> React compares the new virtual DOM with the previous one using the diffing algorithm to find the changes.`,\r\n      `<span class=\"semibold_italic\">Reconciliation Phase:</span> Instead of updating the actual DOM directly, React updates only the changed parts, improving performance.`,\r\n    ],\r\n    contentCodeBlock: `function TextUpdater() {\r\n  const [text, setText] = useState(\"Hello, world!\");\r\n\r\n  const updateText = () => {\r\n    setText(\"Hello, React!\");\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <p>{text}</p>\r\n      <button onClick={updateText}>Change Text</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n/*\r\n  How This Works (Step-by-Step)\r\n\r\n  1. Initial Render:\r\n     - React creates a Virtual DOM for the component with <p>Hello, world!</p>.\r\n\r\n  2. State Update (onClick Event):\r\n     - The button is clicked, updating the state to \"Hello, React!\".\r\n     - A new Virtual DOM tree is created with <p>Hello, React!</p>.\r\n\r\n  3. Diffing (Comparing Old vs. New Virtual DOM):\r\n     - React detects that only the text inside <p> has changed.\r\n\r\n  4. Reconciliation (Efficient Update to Real DOM):\r\n     - Instead of re-rendering the entire <p> element, React updates only the text node inside.\r\n*/`,\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"5. Difference with Real DOM & Shadow DOM\",\r\n    contentTable: {\r\n      headers: [\"Features\", \"Virtual DOM\", \"Real DOM\", \"Shadow DOM\"],\r\n      rows: [\r\n        [\r\n          \"Definition\",\r\n          \"A lightweight copy of the Real DOM used by React to track the changes efficiently before updating the Real DOM.\",\r\n          \"The actual browser-rendered HTML structure that users interact with. \",\r\n          \"A separate, encapsulated DOM inside an element (mostly used in Web Components) to prevent style and script conflicts.\",\r\n        ],\r\n        [\r\n          \"Performance\",\r\n          \"Faster updates due to minimal DOM manipulations.\",\r\n          \"Slower updates as it directly interacts with the browser and whole repaints happen.\",\r\n          \"Improves performance by keeping styles and elements scoped to a single component.\",\r\n        ],\r\n        [\r\n          \"Rendering\",\r\n          \"Creates a virtual tree of React elements that mirrors the actual DOM.\",\r\n          \"Directly renders the HTML structure on the browser.\",\r\n          \"Renders the DOM inside a shadow root, isolated from the main document.\",\r\n        ],\r\n        [\r\n          \"Manipulation\",\r\n          \"React compares old and new VDOM, updating only the necessary parts in the Real DOM.\",\r\n          \"Any change directly affects the page, causing a reflow and repaint.\",\r\n          \"Elements inside a Shadow DOM are independent of the main DOM.\",\r\n        ],\r\n        [\r\n          \"Use Case\",\r\n          \"React uses VDOM to improve performance and reduce re-renders.\",\r\n          \"Traditional websites and applications that don’t use a framework.\",\r\n          \"Web Components that need encapsulation and reusability.\",\r\n        ],\r\n      ],\r\n    },\r\n  },\r\n];\r\n\r\nconst reactComponents = [\r\n  {\r\n    contentName: \"1. Components in React\",\r\n    contentList: [\r\n      `In React, components are the building blocks of the user interface.`,\r\n      `They’re essentially reusable, independent pieces of code that define how a part of the UI should look and behave.`,\r\n      `Think of them like Lego bricks—you can create small pieces like a button or a card and then combine them to build complex interfaces.`,\r\n      `Each component can manage its own state, receive data through props, and render UI based on that data.`,\r\n      `In React, components can be created in two different ways: Class Components and Functional Components.`,\r\n    ],\r\n  },\r\n  {\r\n    contentName: \"a. Class Components\",\r\n    contentList: [\r\n      `Class components are ES6 classes that extend from React.Component and can hold their own state.`,\r\n      `They have a render() method that returns the component’s UI based on the current state and props.`,\r\n      `Class components can also have lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount.`,\r\n      `Before React 16.8, class components were the primary way to create components in React.`,\r\n      `After the introduction of Hooks in React 16.8, functional components became the preferred way to create components due to their simplicity and reusability.`,\r\n      `Now functional components can also use state and lifecycle methods, making class components less common.`,\r\n    ],\r\n    contentCodeBlock: `import React, { Component } from \"react\";\r\n\r\nclass Counter extends Component {\r\n  state = {\r\n    count: 0,\r\n  };\r\n\r\n  increment = () => {\r\n    this.setState({ count: this.state.count + 1 });\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <p>Count: {this.state.count}</p>\r\n        <button onClick={this.increment}>Increment</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Counter;\r\n\r\n/*\r\n  How This Works\r\n\r\n  1. Initial Render:\r\n     - The component renders with count: 0 and a button to increment.\r\n\r\n  2. State Update (onClick Event):\r\n     - The button is clicked, updating the state to count: 1.\r\n     - React re-renders the component with the new state.\r\n*/`,\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"b. Functional Components\",\r\n    contentList: [\r\n      `Functional components are JavaScript functions that return JSX.`,\r\n      `They are simpler, shorter, and easier to read than class components.`,\r\n      `In traditional functional components, you couldn’t use state or lifecycle methods, making them limited in functionality.`,\r\n      `With the introduction of Hooks in React 16.8, functional components can now use state and lifecycle methods, making them more powerful and versatile.`,\r\n    ],\r\n    contentCodeBlock: `import React, { useState } from \"react\";\r\n\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Counter;\r\n\r\n/*\r\n  How This Works\r\n\r\n  1. Initial Render:\r\n     - The component renders with count: 0 and a button to increment.\r\n\r\n  2. State Update (onClick Event):\r\n     - The button is clicked, updating the state to count: 1.\r\n     - React re-renders the component with the new state.\r\n*/`,\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"2. Why not use Class Components?\",\r\n    contentList: [\r\n      `Class components are more verbose and harder to read than functional components.`,\r\n      `They require more boilerplate code, making them slower to write and maintain.`,\r\n      `Class components don’t optimize performance as well as functional components.`,\r\n      `Functional components are easier to test and debug than class components.`,\r\n      `Functional components are more reusable and composable than class components.`,\r\n    ],\r\n  },\r\n  {\r\n    contentName: \"3. When to use what?\",\r\n    contentList: [\r\n      `If you’re starting a new project, use functional components with Hooks for better code quality and maintainability.`,\r\n      `If you're working on legacy code or a project that uses class components, continue using them until you can refactor to functional components.`,\r\n      `Functional components are the future of React and are recommended for all new projects.`,\r\n    ],\r\n  },\r\n  {\r\n    contentName: \"4. Difference between Class & Functional Components\",\r\n    contentTable: {\r\n      headers: [\"Features\", \"Class Components\", \"Functional Components\"],\r\n      rows: [\r\n        [\r\n          \"Definition\",\r\n          \"ES6 classes that extend from React.Component.\",\r\n          \"JavaScript functions that return JSX.\",\r\n        ],\r\n        [\r\n          \"State & Lifecycle\",\r\n          \"Can hold state and use lifecycle methods.\",\r\n          \"Can use state and lifecycle methods with Hooks.\",\r\n        ],\r\n        [\r\n          \"Code Length\",\r\n          \"More verbose and requires more boilerplate code.\",\r\n          \"Shorter, simpler, and easier to read.\",\r\n        ],\r\n        [\r\n          \"Performance\",\r\n          \"Slower performance due to class bindings and lifecycle methods.\",\r\n          \"Faster performance due to fewer bindings and lifecycle methods.\",\r\n        ],\r\n        [\r\n          \"Reusability\",\r\n          \"Less reusable and composable.\",\r\n          \"More reusable and composable.\",\r\n        ],\r\n        [\"Testing\", \"Harder to test and debug.\", \"Easier to test and debug.\"],\r\n        [\r\n          \"Recommended Use\",\r\n          \"Use for legacy code or projects that require class components.\",\r\n          \"Use for new projects or projects that can be refactored.\",\r\n        ],\r\n      ],\r\n    },\r\n  },\r\n];\r\n\r\nconst reactProps = [\r\n  {\r\n    contentName: \"1. Props\",\r\n    contentList: [\r\n      `Props (short for properties) are read-only inputs passed from a parent component to a child component (similar like function arguments).`,\r\n      `They allow components to be reusable and dynamic by sending data like strings, numbers, objects, and functions.`,\r\n      `Props define how the child components should render based on the data passed from the parent components.`,\r\n      `Props are immutable because React follows a unidirectional data flow (one-way binding). The parent controls the data, and the child cannot modify it, ensuring better predictability and maintainability.`,\r\n    ],\r\n    contentCodeBlock: `function ChildComponent({ name, age }) {\r\n  return (\r\n    <>\r\n      <p>Name: {name}</p>\r\n      <p>Age: {age}</p>\r\n    </>\r\n  );\r\n}\r\n\r\nfunction ParentComponent() {\r\n  return <ChildComponent name=\"John Doe\" age={30} />;\r\n}\r\n\r\n/*\r\n  How This Works\r\n  1. ParentComponent: Passes the props 'name' and 'age' to ChildComponent.\r\n  2. ChildComponent: Receives the props and renders them in the JSX.\r\n*/`,\r\n  },\r\n  {\r\n    contentName: \"a. Passing Props\",\r\n    contentList: [\r\n      `Props are passed from parent to child components using attributes.`,\r\n      `Props are passed as key-value pairs, where the key is the prop name and the value is the data to be passed.`,\r\n    ],\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"b. Destructuring Props\",\r\n    contentList: [\r\n      `Props can be destructured inside the child component to access the individual prop values directly.`,\r\n      `Destructuring makes the code cleaner and more readable by extracting the props into separate variables.`,\r\n    ],\r\n    padLeft: true,\r\n    contentCodeBlock: `// Without Destructuring\r\nfunction ChildComponent(props) {\r\n  return (\r\n    <>\r\n      <p>Name: {props.name}</p>\r\n      <p>Age: {props.age}</p>\r\n    </>\r\n  );\r\n\r\n// With Destructuring\r\nfunction ChildComponent({ name, age }) {\r\n  return (\r\n    <>\r\n      <p>Name: {name}</p>\r\n      <p>Age: {age}</p>\r\n    </>\r\n  );\r\n}`,\r\n  },\r\n  {\r\n    contentName: \"c. Default Props\",\r\n    contentList: [\r\n      `Default props are used to set default values for props in case they are not passed from the parent component.`,\r\n      `They help in handling undefined props gracefully and prevent errors.`,\r\n    ],\r\n    padLeft: true,\r\n    contentCodeBlock: `function ChildComponent({ name = \"Anonymous\", age = 0 }) {\r\n  return (\r\n    <>\r\n      <p>Name: {name}</p>\r\n      <p>Age: {age}</p>\r\n    </>\r\n  );\r\n}`,\r\n  },\r\n  {\r\n    contentName:\r\n      \"d. Children Props (Passing Components as Props: Render Props Pattern)\",\r\n    contentList: [\r\n      `The children prop is a special prop that allows passing JSX elements or text or Components as children to another component.`,\r\n      `It is useful for creating reusable components that wrap other components or elements.`,\r\n      `The children prop can be used to create higher-order components (HOCs) or render props patterns.`,\r\n      `It is commonly used for components like modals, tooltips, and cards.`,\r\n    ],\r\n    padLeft: true,\r\n    contentCodeBlock: `function Card({ title, children }) {\r\n  return (\r\n    <div>\r\n      <h2>{title}</h2>\r\n      <div>{children}</div>\r\n    </div>\r\n  );\r\n\r\nfunction App() {\r\n  return (\r\n    <Card title=\"My Card\">\r\n      <p>This is the content of the card.</p>\r\n    </Card>\r\n  );\r\n}`,\r\n  },\r\n  {\r\n    contentName: \"e. Spread Operator with Props\",\r\n    contentList: [\r\n      `The spread operator (...) can be used to pass multiple props to a component without explicitly defining each prop.`,\r\n      `It helps in passing all the props of an object or component to another component.`,\r\n    ],\r\n    padLeft: true,\r\n    contentCodeBlock: `const user = {\r\n  name: \"John Doe\",\r\n  age: 30,\r\n};\r\n\r\nfunction Profile({ name, age }) {\r\n  return (\r\n    <>\r\n      <p>Name: {name}</p>\r\n      <p>Age: {age}</p>\r\n    </>\r\n  );\r\n\r\nfunction App() {\r\n  return <Profile {...user} />;\r\n}`,\r\n  },\r\n  {\r\n    contentName: \"2. Prop Types and Validation\",\r\n    contentList: [\r\n      `PropTypes is a library used for type-checking the props passed to a component.`,\r\n      `It helps in validating the props passed from the parent component to ensure they are of the correct type.`,\r\n      `Common PropTypes include string, number, boolean, array, object, function, etc.`,\r\n      `PropTypes are defined as static properties on the component.`,\r\n    ],\r\n    contentCodeBlock: `import PropTypes from \"prop-types\";\r\n\r\nfunction ChildComponent({ name, age }) {\r\n  return (\r\n    <>\r\n      <p>Name: {name}</p>\r\n      <p>Age: {age}</p>\r\n    </>\r\n  );\r\n\r\nChildComponent.propTypes = {\r\n  name: PropTypes.string.isRequired,\r\n  age: PropTypes.number.isRequired,\r\n};`,\r\n  },\r\n  {\r\n    contentName:\r\n      \"3. How to Update Props? (trigger events from child to parent)\",\r\n    contentList: [\r\n      `Props are immutable and cannot be changed directly by the child component.`,\r\n      `To update props, you can pass callback functions as props from the parent component to the child component.`,\r\n      `The child component can call the callback function to trigger an event in the parent component, updating the props.`,\r\n    ],\r\n    contentCodeBlock: `function ParentComponent() {\r\n  const [name, setName] = useState(\"John Doe\");\r\n\r\n  const updateName = () => {\r\n    setName(\"David Smith\");\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <ChildComponent name={name} updateName={updateName} />\r\n    </>\r\n  );\r\n\r\nfunction ChildComponent({ name, updateName }) {\r\n  return (\r\n    <>\r\n      <p>Name: {name}</p>\r\n      <button onClick={updateName}>Update Name</button>\r\n    </>\r\n  );\r\n}`,\r\n  },\r\n  {\r\n    contentName: \"4. What is props drilling? How to avoid it?\",\r\n    contentList: [\r\n      `Props drilling is the process of passing props through multiple levels of components to reach a deeply nested child component.`,\r\n      `It can make the code harder to maintain and debug, as props have to be passed through intermediary components.`,\r\n      `To avoid props drilling, use React Context API or state management libraries like Redux or MobX.`,\r\n    ],\r\n    contentCodeBlock: `// Using Context API\r\nconst UserContext = React.createContext();\r\n\r\nfunction ParentComponent() {\r\n  const user = { name: \"John Doe\", age: 30 };\r\n\r\n  return (\r\n    <UserContext.Provider value={user}>\r\n      <ChildComponent />\r\n    </UserContext.Provider>\r\n  );\r\n\r\nfunction ChildComponent() {\r\n  const user = useContext(UserContext);\r\n  return (\r\n    <>\r\n      <p>Name: {user.name}</p>\r\n      <p>Age: {user.age}</p>\r\n    </>\r\n  );`,\r\n  },\r\n  {\r\n    contentName: \"5. How do you prevent unnecessary re-renders due to props?\",\r\n    contentList: [\r\n      `To prevent unnecessary re-renders due to props changes, use React.memo() for functional components and PureComponent for class components.`,\r\n      `React.memo() is a higher-order component that memoizes the component based on its props, preventing re-renders if the props haven't changed.`,\r\n      `PureComponent is a class component that does a shallow comparison of props and state to prevent re-renders if they haven't changed.`,\r\n    ],\r\n    contentCodeBlock: `const ChildComponent = React.memo(({ name }) => {\r\n  return <p>Name: {name}</p>;\r\n});`,\r\n  },\r\n  {\r\n    contentName: \"6. How to handle dynamic props in React?\",\r\n    contentList: [\r\n      `To handle dynamic props in React, you can use JavaScript expressions to pass props based on conditions.`,\r\n      `You can also use the spread operator (...) to pass multiple dynamic props to a component.`,\r\n      `Dynamic props help in creating reusable components that can render different content based on the data passed.`,\r\n      `Example: A profile component that renders different user profiles based on the user data passed as props.`,\r\n    ],\r\n  },\r\n  {\r\n    contentName: \"7. Higher-Order Components (HOCs)\",\r\n    contentList: [\r\n      `Higher-Order Components (HOCs) are functions that take a component and return a new component with additional functionality.`,\r\n      `They are used to share code between components, add new props, or modify the behavior of existing components.`,\r\n      `HOCs are a common pattern in React for code reuse, logic abstraction, and enhancing components with new features.`,\r\n      `They allow adding common functionality to multiple components without repeating code.`,\r\n      `HOCs are a flexible and powerful pattern for enhancing components in React applications.`,\r\n      `Example: A withLoading HOC that shows a loading spinner while data is being fetched.`,\r\n    ],\r\n    contentCodeBlock: `function withLoading(Component) {\r\n  return function WithLoadingComponent({ isLoading, ...props }) {\r\n    if (isLoading) return <Spinner />;\r\n    return <Component {...props} />;\r\n  \r\n  function Profile({ user }) {\r\n  return (\r\n    <div>\r\n      <h2>{user.name}</h2>\r\n      <p>{user.bio}</p>\r\n    </div>;\r\n  \r\n  const ProfileWithLoading = withLoading(Profile);\r\n  \r\n  function App() {\r\n    const isLoading = true; // Simulating loading state\r\n    return <ProfileWithLoading user={user} isLoading={isLoading} />;\r\n  }`,\r\n  },\r\n  {\r\n    contentName: \"8. Render Props Pattern\",\r\n    contentList: [\r\n      `The Render Props pattern is a technique for sharing code between React components using a prop whose value is a function.`,\r\n      `It allows components to share logic and data with other components by passing a function as a child prop without repeating the logic.`,\r\n      `The child component can then call the function to access the shared logic or data from the parent component.`,\r\n      `The Render Props pattern is commonly used for code reuse and component composition in React applications.`,\r\n      `It provides a flexible way to pass data and functionality between components.`,\r\n      `They help in separating concerns and keeping components focused on their specific tasks.`,\r\n      `Example: One component that fetches data and another component that renders the fetched data using the Render Props pattern.`,\r\n    ],\r\n    contentCodeBlock: `function DataFetcher({ render }) {\r\n  const data = fetchData(); // Fetch data from API\r\n  return render(data);\r\n}\r\n\r\nfunction Profile({ user }) {\r\n  return (\r\n    <div>\r\n      <h2>{user.name}</h2>\r\n      <p>{user.bio}</p>\r\n    </div>;\r\n}\r\n\r\nfunction App() {\r\n  return (\r\n    <DataFetcher\r\n      render={(data) => (\r\n        <Profile user={data} />\r\n      )}\r\n    />\r\n  );\r\n}`,\r\n  },\r\n  {\r\n    contentName: \"9. When to use HOCS vs Render Props?\",\r\n    contentList: [\r\n      `Use Higher-Order Components (HOCs) when you need to share common logic between multiple components.`,\r\n      `Use Render Props when you need to share data or functionality between components using a prop whose value is a function.`,\r\n      `HOCs are useful for code reuse and logic abstraction, while Render Props are useful for data sharing and component composition.`,\r\n      `Both patterns are powerful and flexible ways to enhance components in React applications.`,\r\n    ],\r\n    contentCodeBlock: `// Example: Use HOCs for sharing common logic\r\nconst ProfileWithLoading = withLoading(Profile);\r\n\r\n// Example: Use Render Props for sharing data\r\n<DataFetcher\r\n  render={(data) => (\r\n    <Profile user={data} />\r\n  )}\r\n/>`,\r\n  },\r\n];\r\n\r\n/* Lists and Keys in React, Event Handling, Conditional Rendering */\r\nconst reactListsAndKeys = [\r\n  {\r\n    contentName: \"1. Lists and Keys in React\",\r\n    contentList: [\r\n      `Lists ares used in React to render multiple elements dynamically based on an array of data. (Ex: users, cart items, products, etc.)`,\r\n      `A key is an unique identifier assigned to each element in a list to help React identify which items have changed, added, or removed.`,\r\n      `Keys help React optimize rendering by reducing re-renders and improving performance.`,\r\n      `Keys should be unique, stable, and consistent across renders to ensure proper reconciliation and avoid bugs.`,\r\n      `If keys are not unique or not provided, React may re-render all the items, causing performance issues. (such as flickering, data loss, inefficient updates, etc.)`,\r\n    ],\r\n    contentCodeBlock: `function ListComponent({ items }) {\r\n  return (\r\n    <ul>\r\n      {items.map((item) => (\r\n        <li key={item.id}>{item.name}</li>\r\n      )}\r\n    </ul>\r\n  );\r\n}`,\r\n  },\r\n  {\r\n    contentName: \"a. Why use Keys? How they work while updating lists?\",\r\n    contentList: [\r\n      `Keys help React identify which items have changed, added, or removed in a list.`,\r\n      `They improve rendering performance by reducing re-renders and optimizing updates.`,\r\n      `Keys are essential for efficient list rendering and proper reconciliation in React applications.`,\r\n      `When an item is added, removed, or reordered in a list, React uses keys to determine the changes and update only the necessary parts of the UI.`,\r\n      `For example, when a new item is added to a list, React compares the keys of the new list with the old list to identify the added item and render it without re-rendering the entire list.`,\r\n    ],\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"b. Best Practices for Keys\",\r\n    contentList: [\r\n      `Keys should be unique, stable, and consistent across renders to ensure proper reconciliation.`,\r\n      `Use string or number keys for better performance and predictability. (like database IDs, UUIDs, etc.)`,\r\n      `For dynamic lists don't use index as keys, as it can cause issues when items are added, removed, or reordered.`,\r\n      `Keys should be assigned to the top-level element inside the map function to ensure proper reconciliation.`,\r\n      `If the list items have unique IDs, use them as keys. Otherwise, generate unique keys using libraries like uuid.`,\r\n    ],\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"2. Event Handling in React\",\r\n    contentList: [\r\n      `Event handling in React is how the UI responds to user interactions like clicks, keypresses, form submissions, etc.`,\r\n      `Event handling in React is similar to handling events in HTML, but with camelCase event names.`,\r\n      `Events are passed as functions (event handlers) to JSX elements and triggered when the event occurs.`,\r\n      `Common events include onClick, onChange, onSubmit, onMouseOver, etc.`,\r\n      `Event handlers receive an event object that contains information about the event (like target, type, etc.).`,\r\n      `To prevent the default behavior of an event (like form submission or link click), use event.preventDefault().`,\r\n    ],\r\n    contentCodeBlock: `function ButtonComponent() {\r\n  const handleClick = () => {\r\n    alert(\"Button Clicked!\");\r\n}\r\n\r\nreturn <button onClick={handleClick}>Click Me</button>;\r\n}`,\r\n  },\r\n  {\r\n    contentName: \"a. Event Object in React\",\r\n    contentList: [\r\n      `The event object contains information about the event like target, type, key, etc.`,\r\n      `It is automatically passed to the event handler function when an event occurs.`,\r\n      `You can access event properties like event.target.value, event.type, event.key, etc.`,\r\n      `The event object can be used to prevent the default behavior of an event using event.preventDefault().`,\r\n    ],\r\n    padLeft: true,\r\n  },\r\n  {\r\n    contentName: \"b. Preventing Default Behavior\",\r\n    contentList: [\r\n      `To prevent the default behavior of an event (like form submission which causes a page reload, or link click which navigates to a new page), use event.preventDefault().`,\r\n      `It stops the default action of the event from occurring.`,\r\n      `Preventing default behavior is useful for handling form submissions, link clicks, and other user interactions.`,\r\n    ],\r\n    padLeft: true,\r\n    contentCodeBlock: `function FormComponent() {\r\n  const handleSubmit = (event) => {\r\n    event.preventDefault();\r\n    alert(\"Form Submitted!\");\r\n  };\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      <input type=\"text\" />\r\n      <button type=\"submit\">Submit</button>\r\n    </form>\r\n  );\r\n}`,\r\n  },\r\n  {\r\n    contentName: \"c. Synthetic Events in React\",\r\n    contentList: [\r\n      `A SyntheticEvent is React’s wrapper around native browser events that ensures cross-browser compatibility and performance optimization.`,\r\n      `Synthetic events are similar to native events but have some differences like event pooling, asynchronous behavior, and automatic cleanup.`,\r\n      `They are automatically cleaned up after the event handler has finished, preventing memory leaks.`,\r\n      `Synthetic events are used to handle events in React components and provide a consistent interface across different browsers.`,\r\n      `Event pooling is a technique used by React to reuse event objects, improving performance and reducing memory usage.`,\r\n      `Events when used in setTimeout or asynchronous functions, the event object may be null or undefined due to the asynchronous nature of React.`,\r\n      `To `\r\n    ]\r\n  },\r\n  {\r\n    contentName: \"3. Conditional Rendering in React\",\r\n    contentList: [\r\n      `Conditional rendering is used to show or hide elements based on a condition in React components.`,\r\n      `You can use JavaScript expressions like if-else, ternary operators, and logical && or || operators for conditional rendering.`,\r\n      `Common use cases for conditional rendering include showing loading spinners, error messages, or rendering components based on user authentication.`,\r\n      `Conditional rendering helps in creating dynamic and interactive user interfaces in React applications.`,\r\n    ],\r\n    contentCodeBlock: `function DataComponent() {\r\n  return <div>Data Loaded!</div>;\r\n}\r\n\r\nfunction Spinner() {\r\n  return <div>Loading...</div>;\r\n}\r\n\r\nfunction Error({ message }) {\r\n  return <div>Error: {message}</div>;\r\n}\r\n\r\n// Using Ternary Operator\r\nreturn isLoading ? <Spinner /> : <DataComponent />;\r\n\r\n// Using Logical && Operator\r\nreturn error && <Error message={error} />;\r\n\r\n// Using If-Else Statement\r\nif (isLoading) {\r\n  return <Spinner />;\r\n} else if (error) {\r\n  return <Error message={error} />;\r\n} else {\r\n  return <DataComponent />;\r\n}`,\r\n  },\r\n];\r\n\r\n\r\nconst reactPortals = [\r\n  {\r\n    contentName: \"1. Portals in React\",\r\n    contentList: [\r\n      `Portals in React provide a way to render children outside the DOM hierarchy of the parent component.`,\r\n      `They allow rendering components into a different part of the DOM, like modals, popovers, tooltips, or overlays.`,\r\n      `Portals help in creating UI components that need to break out of the parent container or have z-index stacking issues.`,\r\n      `Portals are useful for creating overlays, modals, tooltips, and other components that need to be rendered outside the normal flow of the DOM.`,\r\n    ],\r\n    contentCodeBlock: `function Modal({ children }) {\r\n  return ReactDOM.createPortal(\r\n    children,\r\n    document.getElementById(\"modal-root\")\r\n  );\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <h1>App Content</h1>\r\n      <Modal>\r\n        <p>Modal Content</p>\r\n      </Modal>\r\n    </div>\r\n  );\r\n}`,\r\n  },\r\n  {\r\n    contentName: \"a. How Portals work?\",\r\n    contentList: [\r\n      `Portals use ReactDOM.createPortal() to render children into a different part of the DOM.`,\r\n      `The createPortal() function takes two arguments: the children to render and the DOM element to render them into.`,\r\n      `The children are rendered outside the normal DOM hierarchy of the parent component, allowing them to break out of the parent container.`,\r\n      `Real time examples: payment modals, tooltips, popovers, lightboxes, etc.`,\r\n    ],\r\n    padLeft: true,\r\n  }\r\n]\r\n\r\nexport { reactConcepts, reactComponents, reactProps, reactListsAndKeys };\r\n"],"names":["reactConcepts","contentName","contentList","padLeft","contentCodeBlock","contentTable","headers","rows","reactComponents","reactProps","reactListsAndKeys"],"sourceRoot":""}